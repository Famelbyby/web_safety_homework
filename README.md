# Proxy Server
Язык: Go

База данных: MongoDB

На данном сервере работают два порта:
- 8080 - сам прокси-сервер. На него подаются команды вида curl -x http://127.0.0.1:8080 http://mail.ru
- 8000 - веб-апи. Есть следующие пути:
  - /requests - показывает все хранящиеся в базе данных запросы
  - /requests/{id: [0-9]+} - показывает конкретный запрос
  - /repeat/{id: [0-9]+} - повторяет конкретный запрос
  - /scan/{id: [0-9]+} - сканирует на наличие уязвимостей конкретный хост. Алгоритм сканирования описан в разделе https://github.com/Famelbyby/web_safety_homework/tree/main?tab=readme-ov-file#сканер-уязвимости
## Установка
1. Переходим в директорию и прописываем `git clone https://github.com/Famelbyby/web_safety_homework.git` или `git clone git@github.com:Famelbyby/web_safety_homework.git`
2. Переходим в директорию `web_safety_homework`
3. Запускаем генерацию сертификатов: `make gen_certs NAME=$(YOUR NAME) RANDOM_INT=$(YOUR_RANDOM_INT)`. *Примечание:* границы для вычисления числа сделать лучше всего очень большими
4. После этого поднимаем докер: `make run`. Начнётся загрузка и запуск образов
5. Приложение будет запущено
6. Для остановки приложения необходимо прописать `make break`
**Внимание!** При выполнении файла `docker-compose.yml` будут созданы "висячие" образы (их можно обнаружить при выполнении команды `docker images`)
## Проксирование HTTP запросов
Должны успешно проксироваться HTTP запросы. Команда curl -x http://127.0.0.1:8080 http://mail.ru должна возвращать

![image](https://github.com/user-attachments/assets/3650e08d-a8c0-48d8-8a90-4e3fe9fb6c89)

На вход прокси приходит запрос вида

![image](https://github.com/user-attachments/assets/0e15965f-6738-4ed7-b14a-758c28caf671)

Необходимо:
- считать хост и порт из первой строчки
- заменить путь на относительный
- удалить заголовок Proxy-Connection
Отправить на считанный хост (mail.ru:80) получившийся запрос

![image](https://github.com/user-attachments/assets/0f5f2db7-a7d5-47e7-891a-1c8df9e8b02e)


Перенаправить все, что будет получено в ответ

![image](https://github.com/user-attachments/assets/9b461ad4-42a8-41a6-b8b5-1aef49adb362)

Убедиться, что
- проксируются все типы запросов (GET, POST, HEAD, OPTIONS)
- проксируются все заголовки
- корректно возвращаются все коды ответов (200, 302, 404)

## Проксирование HTTPS запросов
Должны успешно проксироваться https запросы. В настройках браузера указать http/https прокси, добавить в ОС корневой сертификат, все сайты должны работать корректно.
Запрос curl -x http://127.0.0.1:8080 https://mail.ru (8080 – порт, на котором запущена программа) должен обрабатываться следующим образом:

На 8080 порт придет в открытом виде запрос CONNECT https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT

![image](https://github.com/user-attachments/assets/70f8b3ba-95d9-41b9-b91f-9863c072c13d)

Необходимо считать хост и порт (mail.ru 443) из первой строчки.
Необходимо сразу вернуть ответ (сокет не закрывать, использовать его для последующего зашифрованного соединения)

HTTP/1.0 200 Connection established

После этого curl начнет установку защищенного соединения. Для установки такого соединения необходимо сгенерировать и подписать сертификат для хоста (mail.ru). Команды для генерации корневого сертификата и сертификата хоста https://github.com/john-pentest/fproxy/blob/master/gen_ca.sh https://github.com/john-pentest/fproxy/blob/master/gen_cert.sh  
Необходимо установить защищенное соединение с хостом (mail.ru:443), отправить в него все, что было получено и расшифровано от curl и вернуть ответ.

Убедиться, что получается зайти на сайт mail.ru, авторизоваться и получить список писем

## Повторная отправка проксированных запросов
Не только проксировать запросы в п.1-2, но и сохранять их вместе с ответом в БД (SQL или NoSQL). 

Запросы необходимо сохранять в распаршеном виде (можно использовать любые библиотеки). Необходимо парсить:

- HTTP метод (GET/POST/PUT/HEAD)
- Путь и GET параметры
- Заголовки, при этом отдельно парсить Cookie
- Тело запроса, в случае application/x-www-form-urlencoded отдельно распасить POST параметры
- Ответы необходимо сохранять также в распаршеном виде
- Не забыть про gzip и другие методы сжатия! (можно либо расшифровывать их, либо изменять заголовки на стороне прокси)

Пример распаршенного запроса:

POST /path1/path2?x=123&y=asd HTTP/1.1

Host: example.org

Header: value

Cookie: cookie1=1; cookie2=qwe;

z = zxc

{
  "method": "POST",
  "path": "/path1/path2",
  "get_params": {
    "x": 123,
    "y": "qwe"
  },
  "headers": {
    "Host": "example.org",
    "Header": "value"
  },
  "cookies": {
    "cookie1": 1,
    "cookie2": "qwe"
  },
  "post_params": {
    "z": "zxc"
  }
}

Пример распаршенного ответа:

HTTP/1.1 200 OK

Server: nginx/1.14.1

Header: value

...

{
  "code": 200,
  "message": "OK",
  "headers": {
    "Server": "nginx/1.14.1",
    "Header": "value"
  },
  "body": "..."
}



Убедиться, что получается записать запрос на авторизацию на сайте mail.ru и заново его отправить
## Сканер уязвимости
Dirbuster – заменить путь (/path/...) по очереди на каждую строчку из словаря https://github.com/maurosoria/dirsearch/blob/master/db/dicc.txt
в качестве результата вывести все файлы, которые вернули не 404 код ответа
